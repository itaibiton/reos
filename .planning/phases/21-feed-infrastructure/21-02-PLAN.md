---
phase: 21-feed-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - convex/posts.ts
  - convex/userFollows.ts
autonomous: true

must_haves:
  truths:
    - "Users can like and unlike posts"
    - "Users can save and unsave posts"
    - "Users can follow and unfollow other users"
    - "Like/save counts update atomically on posts"
  artifacts:
    - path: "convex/posts.ts"
      provides: "Like and save mutations"
      exports: ["likePost", "unlikePost", "savePost", "unsavePost", "isLikedByUser", "isSavedByUser"]
    - path: "convex/userFollows.ts"
      provides: "Follow/unfollow mutations and queries"
      exports: ["followUser", "unfollowUser", "isFollowing", "getFollowers", "getFollowing", "getFollowCounts"]
  key_links:
    - from: "convex/posts.ts"
      to: "postLikes table"
      via: "atomic counter update"
      pattern: "ctx\\.db\\.patch.*likeCount"
    - from: "convex/userFollows.ts"
      to: "userFollows table"
      via: "insert/delete operations"
      pattern: "ctx\\.db\\.(insert|delete)\\(\"userFollows\""
---

<objective>
Add social interaction mutations for likes, saves, and follows with atomic counter updates.

Purpose: Enable users to interact with posts (like, save) and follow other users, completing the social infrastructure layer needed for the feed system.
Output: Like/save mutations with denormalized counter updates on posts, follow/unfollow mutations, and status check queries.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-feed-infrastructure/21-RESEARCH.md
@.planning/phases/21-feed-infrastructure/21-01-SUMMARY.md (after Plan 01)
@convex/schema.ts
@convex/posts.ts

**Depends on Plan 01:**
- posts table with likeCount, saveCount counters
- postLikes, postSaves, userFollows tables with compound indexes
- Base posts.ts file with creation mutations and feed queries
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add like/unlike mutations with atomic counter updates</name>
  <files>convex/posts.ts</files>
  <action>
Add to convex/posts.ts:

1. `likePost` mutation:
   - Args: postId
   - Validate: user authenticated, post exists
   - Check if already liked using by_post_and_user index on postLikes
   - If already liked, return early (idempotent)
   - Insert into postLikes table
   - Atomically increment likeCount on post: `ctx.db.patch(postId, { likeCount: post.likeCount + 1 })`
   - Return success

2. `unlikePost` mutation:
   - Args: postId
   - Validate: user authenticated, post exists
   - Find existing like using by_post_and_user index
   - If not liked, return early (idempotent)
   - Delete from postLikes table
   - Atomically decrement likeCount: `ctx.db.patch(postId, { likeCount: Math.max(0, post.likeCount - 1) })`
   - Use Math.max(0, ...) to prevent negative counts
   - Return success

3. `isLikedByUser` query:
   - Args: postId
   - Get current user from auth
   - Query postLikes by_post_and_user index
   - Return boolean

Pattern for atomic update:
```typescript
const post = await ctx.db.get(args.postId);
if (!post) throw new Error("Post not found");

// Check existing like
const existing = await ctx.db
  .query("postLikes")
  .withIndex("by_post_and_user", (q) =>
    q.eq("postId", args.postId).eq("userId", user._id)
  )
  .unique();

if (existing) return; // Already liked, idempotent

// Insert like
await ctx.db.insert("postLikes", {
  postId: args.postId,
  userId: user._id,
  createdAt: Date.now(),
});

// Update counter
await ctx.db.patch(args.postId, {
  likeCount: post.likeCount + 1,
});
```
  </action>
  <verify>Test: like a post (likeCount increments), like again (no change), unlike (likeCount decrements), unlike again (no change)</verify>
  <done>likePost/unlikePost mutations are idempotent, counters update atomically, isLikedByUser returns correct boolean</done>
</task>

<task type="auto">
  <name>Task 2: Add save/unsave mutations with atomic counter updates</name>
  <files>convex/posts.ts</files>
  <action>
Add to convex/posts.ts:

1. `savePost` mutation:
   - Args: postId
   - Validate: user authenticated, post exists
   - Check if already saved using by_post_and_user index on postSaves
   - If already saved, return early (idempotent)
   - Insert into postSaves table
   - Atomically increment saveCount on post
   - Return success

2. `unsavePost` mutation:
   - Args: postId
   - Validate: user authenticated, post exists
   - Find existing save using by_post_and_user index
   - If not saved, return early (idempotent)
   - Delete from postSaves table
   - Atomically decrement saveCount (use Math.max(0, ...) to prevent negatives)
   - Return success

3. `isSavedByUser` query:
   - Args: postId
   - Get current user from auth
   - Query postSaves by_post_and_user index
   - Return boolean

4. `getSavedPosts` query:
   - Args: paginationOpts
   - Get current user's saved posts (join postSaves with posts)
   - Query postSaves by_user index, order by createdAt desc
   - For each save, get the post and enrich with author/property info
   - Return paginated results

Implementation follows same pattern as like/unlike mutations.
  </action>
  <verify>Test: save a post (saveCount increments), save again (no change), unsave (saveCount decrements), getSavedPosts returns saved posts</verify>
  <done>savePost/unsavePost mutations are idempotent, counters update atomically, isSavedByUser and getSavedPosts work correctly</done>
</task>

<task type="auto">
  <name>Task 3: Create userFollows.ts with follow/unfollow mutations</name>
  <files>convex/userFollows.ts</files>
  <action>
Create new file `convex/userFollows.ts` with:

**Imports:**
```typescript
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";
```

**Mutations:**

1. `followUser` mutation:
   - Args: userId (the user to follow)
   - Validate: user authenticated, target user exists, not following self
   - Check if already following using by_follower_and_following index
   - If already following, return early (idempotent)
   - Insert into userFollows table
   - Return success

2. `unfollowUser` mutation:
   - Args: userId (the user to unfollow)
   - Validate: user authenticated
   - Find existing follow using by_follower_and_following index
   - If not following, return early (idempotent)
   - Delete from userFollows table
   - Return success

**Queries:**

3. `isFollowing` query:
   - Args: userId
   - Get current user from auth
   - Query userFollows by_follower_and_following index
   - Return boolean

4. `getFollowers` query:
   - Args: userId
   - Query userFollows by_following index where followingId = userId
   - For each follow, get follower user info (name, imageUrl, role)
   - Return array of follower info

5. `getFollowing` query:
   - Args: userId
   - Query userFollows by_follower index where followerId = userId
   - For each follow, get following user info (name, imageUrl, role)
   - Return array of following info

6. `getFollowCounts` query:
   - Args: userId
   - Count followers (by_following index)
   - Count following (by_follower index)
   - Return { followerCount, followingCount }

Pattern for follow mutation:
```typescript
// Get current user
const identity = await ctx.auth.getUserIdentity();
if (!identity) throw new Error("Unauthorized");
const currentUser = await ctx.db
  .query("users")
  .withIndex("by_clerk_id", (q) => q.eq("clerkId", identity.subject))
  .unique();
if (!currentUser) throw new Error("User not found");

// Can't follow self
if (currentUser._id === args.userId) {
  throw new Error("Cannot follow yourself");
}

// Check if already following
const existing = await ctx.db
  .query("userFollows")
  .withIndex("by_follower_and_following", (q) =>
    q.eq("followerId", currentUser._id).eq("followingId", args.userId)
  )
  .unique();

if (existing) return; // Already following

// Insert follow
await ctx.db.insert("userFollows", {
  followerId: currentUser._id,
  followingId: args.userId,
  createdAt: Date.now(),
});
```
  </action>
  <verify>npx convex dev --once compiles, follow/unfollow mutations work, isFollowing returns correct state, getFollowCounts returns accurate counts</verify>
  <done>followUser/unfollowUser mutations are idempotent, isFollowing query works, getFollowers/getFollowing return enriched user info, getFollowCounts returns accurate counts</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx convex dev --once` runs without errors
- [ ] likePost creates entry in postLikes, increments likeCount
- [ ] unlikePost removes entry, decrements likeCount (never negative)
- [ ] savePost creates entry in postSaves, increments saveCount
- [ ] unsavePost removes entry, decrements saveCount (never negative)
- [ ] isLikedByUser and isSavedByUser return correct booleans
- [ ] getSavedPosts returns paginated saved posts
- [ ] followUser creates entry in userFollows
- [ ] unfollowUser removes entry
- [ ] Cannot follow self (throws error)
- [ ] isFollowing returns correct boolean
- [ ] getFollowCounts returns accurate follower/following counts
- [ ] All mutations are idempotent (calling twice has same effect as once)
</verification>

<success_criteria>
- Like/save mutations update counters atomically
- All interaction mutations are idempotent
- Follow system complete with followers/following queries
- Status check queries (isLikedByUser, isSavedByUser, isFollowing) work correctly
- Feed infrastructure ready for Phase 22 (Post Creation UI)
</success_criteria>

<output>
After completion, create `.planning/phases/21-feed-infrastructure/21-02-SUMMARY.md`
</output>
