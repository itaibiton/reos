---
phase: 21-feed-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/posts.ts
autonomous: true

must_haves:
  truths:
    - "Posts table exists with discriminated union for post types"
    - "Feed queries return paginated results for authenticated users"
    - "Users can create property, service request, and discussion posts"
  artifacts:
    - path: "convex/schema.ts"
      provides: "posts, postLikes, postSaves, userFollows tables"
      contains: "posts: defineTable"
    - path: "convex/posts.ts"
      provides: "Post creation mutations and feed queries"
      exports: ["createPropertyPost", "createServiceRequestPost", "createDiscussionPost", "globalFeed", "userFeed"]
  key_links:
    - from: "convex/posts.ts"
      to: "convex/schema.ts"
      via: "table references"
      pattern: "ctx\\.db\\.insert\\(\"posts\""
---

<objective>
Create the core feed infrastructure schema and queries for the social feed system.

Purpose: Establish the data model for posts with discriminated union types (property listing, service request, discussion) and implement paginated feed queries using Convex's built-in pagination.
Output: Schema with 4 new tables (posts, postLikes, postSaves, userFollows), post creation mutations, and feed queries with pagination support.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-feed-infrastructure/21-RESEARCH.md
@convex/schema.ts

**Key research findings:**
- Single posts table with discriminated union (postType field as discriminator)
- Convex built-in pagination with paginationOptsValidator and .paginate()
- Denormalized counters (likeCount, commentCount, etc.) on post documents
- Visibility enum (public, followers_only, deal_participants) with query-time filtering
- Supporting tables: postLikes, postSaves, userFollows with compound indexes
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add feed infrastructure tables to schema</name>
  <files>convex/schema.ts</files>
  <action>
Add to schema.ts:

1. Define type unions at top of file (after existing unions):

```typescript
// Post type discriminator
const postType = v.union(
  v.literal("property_listing"),
  v.literal("service_request"),
  v.literal("discussion")
);

// Post visibility
const postVisibility = v.union(
  v.literal("public"),
  v.literal("followers_only"),
  v.literal("deal_participants")
);

// Service types for posts (reuse providerType if possible)
const serviceTypeForPost = v.union(
  v.literal("broker"),
  v.literal("mortgage_advisor"),
  v.literal("lawyer")
);
```

2. Add posts table:
```typescript
posts: defineTable({
  authorId: v.id("users"),
  postType: postType,
  content: v.string(),
  visibility: postVisibility,
  propertyId: v.optional(v.id("properties")),
  dealId: v.optional(v.id("deals")),
  serviceType: v.optional(serviceTypeForPost),
  likeCount: v.number(),
  commentCount: v.number(),
  shareCount: v.number(),
  saveCount: v.number(),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_author", ["authorId"])
  .index("by_author_and_time", ["authorId", "createdAt"])
  .index("by_type", ["postType"])
  .index("by_visibility_and_time", ["visibility", "createdAt"])
  .index("by_property", ["propertyId"]),
```

3. Add postLikes table:
```typescript
postLikes: defineTable({
  postId: v.id("posts"),
  userId: v.id("users"),
  createdAt: v.number(),
})
  .index("by_post", ["postId"])
  .index("by_user", ["userId"])
  .index("by_post_and_user", ["postId", "userId"]),
```

4. Add postSaves table:
```typescript
postSaves: defineTable({
  postId: v.id("posts"),
  userId: v.id("users"),
  createdAt: v.number(),
})
  .index("by_post", ["postId"])
  .index("by_user", ["userId"])
  .index("by_post_and_user", ["postId", "userId"]),
```

5. Add userFollows table:
```typescript
userFollows: defineTable({
  followerId: v.id("users"),
  followingId: v.id("users"),
  createdAt: v.number(),
})
  .index("by_follower", ["followerId"])
  .index("by_following", ["followingId"])
  .index("by_follower_and_following", ["followerId", "followingId"]),
```
  </action>
  <verify>npx convex dev --once deploys without schema errors</verify>
  <done>Four new tables (posts, postLikes, postSaves, userFollows) exist in schema with proper indexes</done>
</task>

<task type="auto">
  <name>Task 2: Create posts.ts with creation mutations and feed queries</name>
  <files>convex/posts.ts</files>
  <action>
Create new file `convex/posts.ts` with:

**Imports:**
```typescript
import { query, mutation } from "./_generated/server";
import { paginationOptsValidator } from "convex/server";
import { v } from "convex/values";
```

**Post Creation Mutations:**

1. `createPropertyPost` mutation:
   - Args: propertyId (required), content, visibility (public | followers_only)
   - Validate: user authenticated, property exists
   - Insert post with postType: "property_listing", initialize counters to 0

2. `createServiceRequestPost` mutation:
   - Args: content, serviceType (broker | mortgage_advisor | lawyer), visibility
   - Validate: user authenticated
   - Insert post with postType: "service_request", initialize counters to 0

3. `createDiscussionPost` mutation:
   - Args: content, visibility
   - Validate: user authenticated
   - Insert post with postType: "discussion", initialize counters to 0

**Feed Queries:**

4. `globalFeed` query:
   - Args: paginationOpts, optional postType filter
   - Query posts with visibility "public", order desc by createdAt
   - Use .paginate(args.paginationOpts)
   - Enrich with author info (name, imageUrl, role from users table)
   - For property_listing posts, include property preview (title, city, priceUsd, featuredImage)
   - Filter by postType in memory if specified
   - Return paginated results with enriched page

5. `userFeed` query:
   - Args: userId, paginationOpts
   - Query posts by authorId using by_author_and_time index, order desc
   - Only return posts visible to current user (public, or followers_only if following, or own posts)
   - Enrich with author and property info
   - Return paginated results

**Helper pattern for enrichment:**
```typescript
async function enrichPost(ctx, post) {
  const author = await ctx.db.get(post.authorId);
  let property = null;
  if (post.postType === "property_listing" && post.propertyId) {
    const prop = await ctx.db.get(post.propertyId);
    if (prop) {
      property = {
        _id: prop._id,
        title: prop.title,
        city: prop.city,
        priceUsd: prop.priceUsd,
        featuredImage: prop.featuredImage,
      };
    }
  }
  return {
    ...post,
    authorName: author?.name || author?.email || "Unknown",
    authorImageUrl: author?.imageUrl,
    authorRole: author?.role,
    property,
  };
}
```

Use existing REOS patterns from messages.ts and deals.ts for query structure.
  </action>
  <verify>npx convex dev --once compiles, mutations and queries appear in Convex dashboard functions list</verify>
  <done>createPropertyPost, createServiceRequestPost, createDiscussionPost mutations work; globalFeed and userFeed return paginated, enriched posts</done>
</task>

<task type="auto">
  <name>Task 3: Add followingFeed query with visibility helper</name>
  <files>convex/posts.ts</files>
  <action>
Add to convex/posts.ts:

1. `canViewPost` internal helper function:
```typescript
async function canViewPost(
  ctx: QueryCtx,
  post: Doc<"posts">,
  viewerId: Id<"users">
): Promise<boolean> {
  // Author can always see own posts
  if (post.authorId === viewerId) return true;

  switch (post.visibility) {
    case "public":
      return true;
    case "followers_only":
      const follows = await ctx.db
        .query("userFollows")
        .withIndex("by_follower_and_following", (q) =>
          q.eq("followerId", viewerId).eq("followingId", post.authorId)
        )
        .unique();
      return follows !== null;
    case "deal_participants":
      if (!post.dealId) return false;
      const deal = await ctx.db.get(post.dealId);
      if (!deal) return false;
      return (
        deal.investorId === viewerId ||
        deal.brokerId === viewerId ||
        deal.mortgageAdvisorId === viewerId ||
        deal.lawyerId === viewerId
      );
    default:
      return false;
  }
}
```

2. `followingFeed` query:
   - Args: paginationOpts
   - Get current user from auth
   - Get list of users the current user follows (from userFollows by_follower index)
   - Query public posts, paginate
   - Filter in memory to: posts from followed users OR own posts
   - Enrich with author and property info
   - Return paginated results

Note: In-memory filtering after pagination is acceptable per research (Convex single-index constraint). For MVP, over-fetch slightly to account for filtering.

3. `getPost` query:
   - Args: postId
   - Get post by ID
   - Verify current user can view (using canViewPost)
   - Enrich with author and property info
   - Return enriched post or null if not viewable
  </action>
  <verify>npx convex dev --once compiles, followingFeed returns posts from followed users, getPost respects visibility</verify>
  <done>followingFeed query filters to followed users, canViewPost helper enforces visibility rules, getPost returns single enriched post</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx convex dev --once` runs without errors
- [ ] posts, postLikes, postSaves, userFollows tables appear in Convex dashboard
- [ ] createPropertyPost mutation creates post with propertyId reference
- [ ] createServiceRequestPost mutation creates post with serviceType
- [ ] createDiscussionPost mutation creates simple discussion post
- [ ] globalFeed returns paginated posts with author info
- [ ] userFeed returns posts by specific user
- [ ] followingFeed filters to followed users only
- [ ] All counters (likeCount, etc.) initialize to 0
</verification>

<success_criteria>
- All 4 tables deployed to Convex
- Post creation mutations work for all 3 post types
- Feed queries return paginated, enriched results
- Visibility helper correctly restricts access
- Ready for Plan 02 to add interaction mutations
</success_criteria>

<output>
After completion, create `.planning/phases/21-feed-infrastructure/21-01-SUMMARY.md`
</output>
