---
phase: 62-context-awareness-help-guidance
plan: 02
type: execute
wave: 2
depends_on: ["62-01"]
files_modified:
  - src/components/ai/hooks/usePageContext.ts
  - src/components/ai/hooks/useSuggestedPrompts.ts
  - src/components/ai/hooks/useAIAssistantChat.ts
  - src/components/ai/SuggestedPrompts.tsx
  - src/components/ai/AIAssistantPanel.tsx
  - messages/en.json
  - messages/he.json
autonomous: true

must_haves:
  truths:
    - "The AI assistant detects the current page and entity from the URL without any per-page integration"
    - "Every sendMessage call includes the current page context automatically"
    - "Suggested prompts change based on the current page type"
    - "Suggested prompt chips appear when the conversation is empty"
    - "Clicking a suggested prompt sends it as a message with page context included"
    - "All suggested prompt text is translated in English and Hebrew"
  artifacts:
    - path: "src/components/ai/hooks/usePageContext.ts"
      provides: "usePageContext hook parsing pathname and params into PageContext"
      exports: ["usePageContext", "PageContext"]
    - path: "src/components/ai/hooks/useSuggestedPrompts.ts"
      provides: "useSuggestedPrompts hook returning translated prompts by pageType"
      exports: ["useSuggestedPrompts"]
    - path: "src/components/ai/SuggestedPrompts.tsx"
      provides: "SuggestedPrompts component rendering prompt chips"
      exports: ["SuggestedPrompts"]
  key_links:
    - from: "src/components/ai/hooks/useAIAssistantChat.ts"
      to: "convex/ai/chat.ts sendMessage"
      via: "pageContext included in sendMessageAction call"
      pattern: "pageContext"
    - from: "src/components/ai/hooks/usePageContext.ts"
      to: "src/components/ai/hooks/useAIAssistantChat.ts"
      via: "pageContext passed as argument to useAIAssistantChat"
      pattern: "usePageContext"
    - from: "src/components/ai/AIAssistantPanel.tsx"
      to: "src/components/ai/SuggestedPrompts.tsx"
      via: "SuggestedPrompts rendered in AssistantChatContent"
      pattern: "SuggestedPrompts"
---

<objective>
Add frontend page context detection, wire it into the chat hook, and build suggested prompts UI.

Purpose: Complete the context awareness loop -- the frontend detects what the user is viewing, sends lightweight context with every message, and shows contextual prompt suggestions. This makes the assistant immediately useful on any page without the user having to explain what they are looking at.

Output: `usePageContext` hook, `useSuggestedPrompts` hook, `SuggestedPrompts` component, wired `useAIAssistantChat` sending pageContext, and i18n translations for all prompt strings.
</objective>

<execution_context>
@/Users/Kohelet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Kohelet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/62-context-awareness-help-guidance/62-RESEARCH.md
@.planning/phases/62-context-awareness-help-guidance/62-01-SUMMARY.md
@src/components/ai/hooks/useAIAssistantChat.ts
@src/components/ai/AIAssistantPanel.tsx
@src/components/ai/AIChatInput.tsx
@src/providers/AIAssistantProvider.tsx
@messages/en.json
@messages/he.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create usePageContext hook and useSuggestedPrompts hook</name>
  <files>
    src/components/ai/hooks/usePageContext.ts
    src/components/ai/hooks/useSuggestedPrompts.ts
  </files>
  <action>
**File 1: `src/components/ai/hooks/usePageContext.ts`**

Create a hook that parses the current URL into a structured PageContext object.

```typescript
"use client";

import { usePathname } from "@/i18n/navigation";
import { useParams } from "next/navigation";

export interface PageContext {
  pageType: string;
  entityType?: "property" | "deal" | "provider" | "client" | "user";
  entityId?: string;
}
```

`usePageContext()` implementation:
- Use `usePathname()` from `@/i18n/navigation` (already strips locale prefix).
- Use `useParams()` from `next/navigation` for route params.
- Match routes in this order (more specific first):

```
/properties/saved      -> { pageType: "property_saved" }
/properties/listings   -> { pageType: "property_listings" }
/properties/new        -> { pageType: "property_create" }
/properties/[id]/edit  -> { pageType: "property_edit", entityType: "property", entityId: params.id }
/properties/[id]       -> { pageType: "property_detail", entityType: "property", entityId: params.id }
/properties            -> { pageType: "property_browse" }

/deals/[id]            -> { pageType: "deal_detail", entityType: "deal", entityId: params.id }
/deals                 -> { pageType: "deals_list" }

/providers/[id]        -> { pageType: "provider_detail", entityType: "provider", entityId: params.id }
/providers             -> { pageType: "providers_browse" }

/clients/[id]          -> { pageType: "client_detail", entityType: "client", entityId: params.id }
/dashboard/clients/[clientId] -> { pageType: "client_detail", entityType: "client", entityId: params.clientId }

/profile/investor/summary -> { pageType: "profile_summary" }
/profile/investor      -> { pageType: "profile_investor" }
/profile/provider      -> { pageType: "profile_provider" }
/profile/[id]          -> { pageType: "profile_detail", entityType: "user", entityId: params.id }

/dashboard             -> { pageType: "dashboard" }
/feed                  -> { pageType: "social_feed" }
/chat                  -> { pageType: "messaging" }
/search                -> { pageType: "search" }
/analytics             -> { pageType: "analytics" }
/settings              -> { pageType: "settings" }
/onboarding/questionnaire -> { pageType: "onboarding_questionnaire" }
/onboarding/vendor-profile -> { pageType: "onboarding_vendor" }
/onboarding            -> { pageType: "onboarding" }
```

Fallback: Extract first path segment, return `{ pageType: segment || "dashboard" }`.

IMPORTANT: For entity detail pages, extract `params.id` as string. Use `String(params.id)` to handle potential array params. Only set entityType/entityId when the param actually exists (truthy check).

IMPORTANT: Check for specific sub-paths BEFORE the generic `startsWith` checks. For example, check `/properties/saved` before `/properties/[id]`. The pathname `/properties/saved` would match `startsWith("/properties/")` and `params.id` might be "saved".

Pattern for entity pages:
```typescript
// Properties with sub-routes first
if (pathname === "/properties/saved") return { pageType: "property_saved" };
if (pathname === "/properties/listings") return { pageType: "property_listings" };
if (pathname === "/properties/new") return { pageType: "property_create" };
if (pathname.match(/^\/properties\/[^/]+\/edit$/)) {
  const id = params.id ? String(params.id) : undefined;
  if (id) return { pageType: "property_edit", entityType: "property", entityId: id };
}
if (pathname.match(/^\/properties\/[^/]+$/) && params.id) {
  return { pageType: "property_detail", entityType: "property", entityId: String(params.id) };
}
if (pathname === "/properties") return { pageType: "property_browse" };
```

Follow this same pattern for deals, providers, clients, profile.

**File 2: `src/components/ai/hooks/useSuggestedPrompts.ts`**

Create a hook that returns translated suggested prompts based on pageType.

```typescript
"use client";

import { useTranslations } from "next-intl";
import { useMemo } from "react";
```

Define a constant `PROMPT_KEYS_BY_PAGE_TYPE` mapping pageType to arrays of translation keys:

```typescript
const PROMPT_KEYS_BY_PAGE_TYPE: Record<string, string[]> = {
  property_detail: [
    "propertyDetail.investmentAnalysis",
    "propertyDetail.comparison",
    "propertyDetail.startDeal",
  ],
  deal_detail: [
    "dealDetail.nextStep",
    "dealDetail.currentStage",
    "dealDetail.documents",
  ],
  property_browse: [
    "propertyBrowse.matchProfile",
    "propertyBrowse.bestAreas",
    "propertyBrowse.explainTypes",
  ],
  deals_list: [
    "dealsList.summary",
    "dealsList.attention",
    "dealsList.explainStages",
  ],
  dashboard: [
    "dashboard.portfolio",
    "dashboard.nextAction",
    "dashboard.help",
  ],
  providers_browse: [
    "providersBrowse.findBroker",
    "providersBrowse.mortgageAdvice",
    "providersBrowse.recommend",
  ],
  provider_detail: [
    "providerDetail.evaluate",
    "providerDetail.connect",
    "providerDetail.compare",
  ],
  property_saved: [
    "propertySaved.compare",
    "propertySaved.bestMatch",
    "propertySaved.nextStep",
  ],
  onboarding_questionnaire: [
    "onboarding.helpQuestion",
    "onboarding.whyMatters",
    "onboarding.canChange",
  ],
  settings: [
    "settings.help",
    "settings.features",
  ],
};
```

The hook `useSuggestedPrompts(pageType: string)`:
- Uses `useTranslations("aiAssistant.suggestions")`.
- Gets the keys for the pageType (fallback to `dashboard` keys if not found, then to empty array).
- Maps each key through `t(key)` to get the translated string.
- Returns the array of translated strings.
- Wrap in `useMemo` keyed on `pageType` (the translations are stable).

Export the hook.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compilation. Check that both files export their hooks and types correctly.
  </verify>
  <done>
`usePageContext` hook exists and correctly maps all documented routes to PageContext objects. `useSuggestedPrompts` hook exists and returns translated prompt strings keyed by pageType.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire pageContext into useAIAssistantChat, build SuggestedPrompts component, update panel and i18n</name>
  <files>
    src/components/ai/hooks/useAIAssistantChat.ts
    src/components/ai/SuggestedPrompts.tsx
    src/components/ai/AIAssistantPanel.tsx
    messages/en.json
    messages/he.json
  </files>
  <action>
**File 1: Modify `src/components/ai/hooks/useAIAssistantChat.ts`**

The hook needs to accept pageContext and include it with every sendMessage call.

1. Add import: `import { type PageContext } from "./usePageContext";`

2. Change the hook signature to accept pageContext:
```typescript
export function useAIAssistantChat(pageContext?: PageContext) {
```

3. In the `sendMessage` callback, include pageContext in the action call:
```typescript
const sendMessage = useCallback(
  async (text: string) => {
    if (!text.trim()) return;
    setError(null);
    setIsSending(true);
    try {
      await sendMessageAction({
        message: text,
        ...(pageContext && {
          pageContext: {
            pageType: pageContext.pageType,
            ...(pageContext.entityType && { entityType: pageContext.entityType }),
            ...(pageContext.entityId && { entityId: pageContext.entityId }),
          },
        }),
      });
    } catch (err) {
      if (err instanceof Error && !err.message.includes("abort")) {
        setError(err.message);
      }
    } finally {
      setIsSending(false);
    }
  },
  [sendMessageAction, pageContext]
);
```

IMPORTANT: Add `pageContext` to the useCallback dependency array. This ensures that when the user navigates to a new page, the next sendMessage call uses the fresh context. The `pageContext` object reference changes on navigation because `usePathname` and `useParams` return new values.

IMPORTANT: Do NOT memoize pageContext with useMemo -- let it be fresh on every call. The callback will use the latest value when invoked.

Actually, since `pageContext` is in the deps array and is a new object on every render, this could cause unnecessary re-creation of `sendMessage`. To fix this, use a ref for pageContext:

```typescript
import { useCallback, useState, useRef, useEffect } from "react";

// Inside the hook:
const pageContextRef = useRef(pageContext);
useEffect(() => {
  pageContextRef.current = pageContext;
}, [pageContext]);
```

Then in the sendMessage callback, read from `pageContextRef.current` instead of `pageContext`, and do NOT include pageContext in the dependency array. This ensures:
- sendMessage callback is stable (no unnecessary re-renders in consumers)
- pageContext is always fresh when sendMessage is actually called

**File 2: Create `src/components/ai/SuggestedPrompts.tsx`**

A simple component rendering clickable prompt chips.

```typescript
"use client";

import { cn } from "@/lib/utils";

interface SuggestedPromptsProps {
  prompts: string[];
  onSelect: (prompt: string) => void;
  className?: string;
}

export function SuggestedPrompts({ prompts, onSelect, className }: SuggestedPromptsProps) {
  if (prompts.length === 0) return null;

  return (
    <div className={cn("flex flex-wrap gap-2 px-4 py-3", className)}>
      {prompts.map((prompt) => (
        <button
          key={prompt}
          type="button"
          onClick={() => onSelect(prompt)}
          className={cn(
            "text-xs px-3 py-1.5 rounded-full border",
            "bg-muted/50 hover:bg-muted",
            "text-muted-foreground hover:text-foreground",
            "transition-colors cursor-pointer",
            "text-start" // For RTL support
          )}
        >
          {prompt}
        </button>
      ))}
    </div>
  );
}
```

No `"use client"` directive needed since parent is already client. Actually, add it anyway since this file has event handlers -- follow the codebase pattern where component files that use interactivity have the directive.

**File 3: Modify `src/components/ai/AIAssistantPanel.tsx`**

Update `AssistantChatContent` to:

1. Add imports:
```typescript
import { usePageContext } from "./hooks/usePageContext";
import { useSuggestedPrompts } from "./hooks/useSuggestedPrompts";
import { SuggestedPrompts } from "./SuggestedPrompts";
```

2. Inside `AssistantChatContent`, add hook calls before the existing `useAIAssistantChat`:
```typescript
const pageContext = usePageContext();
const suggestedPrompts = useSuggestedPrompts(pageContext.pageType);
```

3. Pass pageContext to useAIAssistantChat:
```typescript
const {
  messages,
  isStreaming,
  isLoading,
  error,
  sendMessage,
  stopGeneration,
  clearMemory,
} = useAIAssistantChat(pageContext);
```

4. Add SuggestedPrompts between the message list and the input, shown only when there are no messages and not loading:
```typescript
{/* Suggested prompts - shown when conversation is empty */}
{!isLoading && messages.length === 0 && suggestedPrompts.length > 0 && (
  <SuggestedPrompts
    prompts={suggestedPrompts}
    onSelect={sendMessage}
  />
)}
```

Place this AFTER the `StreamingChatMessageList` and BEFORE the `AIChatInput` in the JSX. This positions the prompts above the input area, which is the natural location for suggestions.

**File 4 & 5: Add i18n translations to `messages/en.json` and `messages/he.json`**

Add a `"suggestions"` section inside the existing `"aiAssistant"` key.

In `messages/en.json`, add inside `"aiAssistant"`:
```json
"suggestions": {
  "propertyDetail": {
    "investmentAnalysis": "What do you think of this property as an investment?",
    "comparison": "How does this compare to similar properties?",
    "startDeal": "What should I know before starting a deal?"
  },
  "dealDetail": {
    "nextStep": "What's the next step in this deal?",
    "currentStage": "Help me understand the current stage",
    "documents": "What documents do I need?"
  },
  "propertyBrowse": {
    "matchProfile": "Help me find properties matching my profile",
    "bestAreas": "What areas have the best investment potential?",
    "explainTypes": "Explain the property types available"
  },
  "dealsList": {
    "summary": "Show me a summary of my active deals",
    "attention": "Which deal needs my attention?",
    "explainStages": "Explain the deal stages"
  },
  "dashboard": {
    "portfolio": "Give me a summary of my portfolio",
    "nextAction": "What should I do next?",
    "help": "Help me understand my dashboard"
  },
  "providersBrowse": {
    "findBroker": "Help me find a broker for my area",
    "mortgageAdvice": "What should I look for in a mortgage advisor?",
    "recommend": "Recommend providers for my investment team"
  },
  "providerDetail": {
    "evaluate": "What can you tell me about this provider?",
    "connect": "How do I connect with this provider?",
    "compare": "How does this provider compare to others?"
  },
  "propertySaved": {
    "compare": "Compare my saved properties",
    "bestMatch": "Which saved property is the best match for me?",
    "nextStep": "What should I do with my saved properties?"
  },
  "onboarding": {
    "helpQuestion": "Help me with this question",
    "whyMatters": "Why does this matter for my recommendations?",
    "canChange": "Can I change my answers later?"
  },
  "settings": {
    "help": "What settings can I change?",
    "features": "What features does the platform offer?"
  }
}
```

In `messages/he.json`, add the same structure with Hebrew translations:
```json
"suggestions": {
  "propertyDetail": {
    "investmentAnalysis": "מה דעתך על הנכס הזה כהשקעה?",
    "comparison": "איך הנכס הזה משתווה לנכסים דומים?",
    "startDeal": "מה כדאי לדעת לפני שמתחילים עסקה?"
  },
  "dealDetail": {
    "nextStep": "מה השלב הבא בעסקה?",
    "currentStage": "עזור לי להבין את השלב הנוכחי",
    "documents": "אילו מסמכים אני צריך?"
  },
  "propertyBrowse": {
    "matchProfile": "עזור לי למצוא נכסים שמתאימים לפרופיל שלי",
    "bestAreas": "אילו אזורים הם הכי טובים להשקעה?",
    "explainTypes": "הסבר את סוגי הנכסים הזמינים"
  },
  "dealsList": {
    "summary": "הצג לי סיכום של העסקאות הפעילות שלי",
    "attention": "איזו עסקה דורשת את תשומת הלב שלי?",
    "explainStages": "הסבר את שלבי העסקה"
  },
  "dashboard": {
    "portfolio": "תן לי סיכום של התיק שלי",
    "nextAction": "מה כדאי לי לעשות עכשיו?",
    "help": "עזור לי להבין את לוח המחוונים"
  },
  "providersBrowse": {
    "findBroker": "עזור לי למצוא מתווך באזור שלי",
    "mortgageAdvice": "מה לחפש ביועץ משכנתאות?",
    "recommend": "המלץ על נותני שירות לצוות ההשקעות שלי"
  },
  "providerDetail": {
    "evaluate": "מה אתה יכול לספר לי על נותן השירות הזה?",
    "connect": "איך אני מתחבר לנותן השירות הזה?",
    "compare": "איך נותן השירות הזה משתווה לאחרים?"
  },
  "propertySaved": {
    "compare": "השווה את הנכסים השמורים שלי",
    "bestMatch": "איזה נכס שמור הכי מתאים לי?",
    "nextStep": "מה כדאי לעשות עם הנכסים השמורים שלי?"
  },
  "onboarding": {
    "helpQuestion": "עזור לי עם השאלה הזו",
    "whyMatters": "למה זה חשוב להמלצות שלי?",
    "canChange": "אפשר לשנות את התשובות שלי אחר כך?"
  },
  "settings": {
    "help": "אילו הגדרות אני יכול לשנות?",
    "features": "אילו תכונות יש לפלטפורמה?"
  }
}
```

IMPORTANT: Read the FULL en.json and he.json files first to find the exact location of the `"aiAssistant"` key, and insert the `"suggestions"` section at the END of the `"aiAssistant"` object (before its closing brace). Do NOT accidentally overwrite existing keys.
  </action>
  <verify>
1. Run `npx tsc --noEmit` to verify TypeScript compilation across all modified files.
2. Run `npx next build` or verify the dev server starts without errors.
3. Verify in `messages/en.json` that `aiAssistant.suggestions.propertyDetail.investmentAnalysis` resolves to a string.
4. Check that `useAIAssistantChat` now accepts a `PageContext` parameter and includes it in sendMessage calls.
  </verify>
  <done>
- `usePageContext` hook detects current page/entity from URL for all documented routes
- `useSuggestedPrompts` hook returns translated prompt strings by pageType
- `SuggestedPrompts` component renders clickable chips above the input
- `useAIAssistantChat` includes pageContext in every sendMessage call via a ref (stable callback)
- `AIAssistantPanel` wires all hooks together: detects page, shows prompts when empty, sends context
- All 30+ suggested prompt strings translated in both English and Hebrew
- Clicking a suggested prompt sends it as a normal message with full page context
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes across all frontend files
2. On a property detail page, opening the AI panel shows property-specific suggested prompts
3. Sending a message from a property detail page includes `pageContext: { pageType: "property_detail", entityType: "property", entityId: "..." }` in the action call
4. On the dashboard, different suggested prompts appear
5. Navigating between pages updates the suggested prompts without reopening the panel
6. Hebrew translations display correctly for all suggested prompts
7. Suggested prompts disappear once the first message is sent (messages.length > 0)
</verification>

<success_criteria>
- Page context is detected from URL and sent with every message
- Suggested prompts appear on empty conversations, contextualized to the current page
- All prompt text is translated in English and Hebrew
- The sendMessage callback remains stable (ref pattern prevents re-render cascades)
- SuggestedPrompts component handles RTL layout correctly
- The panel works correctly on both desktop (Sheet) and mobile (Drawer)
</success_criteria>

<output>
After completion, create `.planning/phases/62-context-awareness-help-guidance/62-02-SUMMARY.md`
</output>
