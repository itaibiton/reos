---
phase: 41-conversational-ai-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - convex/ai/messages.ts
  - src/components/ai/hooks/useAIChat.ts
  - src/components/ai/hooks/useSmartScroll.ts
autonomous: true

must_haves:
  truths:
    - "Frontend can retrieve AI conversation messages"
    - "Hook manages sending messages and tracking streaming state"
    - "AI messages display with formatted text including code blocks"
  artifacts:
    - path: "convex/ai/messages.ts"
      provides: "Public action for listing AI messages"
      exports: ["listMessages"]
    - path: "src/components/ai/hooks/useAIChat.ts"
      provides: "React hook for AI chat state management"
      exports: ["useAIChat"]
    - path: "src/components/ai/hooks/useSmartScroll.ts"
      provides: "Smart auto-scroll hook with Intersection Observer"
      exports: ["useSmartScroll"]
  key_links:
    - from: "convex/ai/messages.ts"
      to: "investorAssistant.listMessages"
      via: "agent listMessages API in action context"
      pattern: "investorAssistant\\.listMessages"
    - from: "src/components/ai/hooks/useAIChat.ts"
      to: "api.ai.chat.sendMessage"
      via: "useAction hook"
      pattern: "useAction.*sendMessage"
    - from: "src/components/ai/hooks/useAIChat.ts"
      to: "api.ai.messages.listMessages"
      via: "useAction hook with refetch pattern"
      pattern: "useAction.*listMessages"
---

<objective>
Install markdown dependencies and create the data/state foundation for the AI chat interface.

Purpose: Establish the hooks and actions that UI components will consume. Without this foundation, components cannot display messages or send new ones.

Output: React hooks for chat state management, Convex action for message listing, and npm packages for markdown rendering.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-conversational-ai-core/41-CONTEXT.md
@.planning/phases/41-conversational-ai-core/41-RESEARCH.md
@.planning/phases/40-ai-infrastructure-foundation/40-03-SUMMARY.md

# Phase 40 infrastructure files
@convex/ai/chat.ts
@convex/ai/threads.ts
@convex/ai/agent.ts
@convex/_generated/api.d.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install markdown rendering dependencies</name>
  <files>package.json</files>
  <action>
Install react-markdown and react-syntax-highlighter for rendering AI responses with code highlighting.

Run:
```bash
npm install react-markdown react-syntax-highlighter
npm install --save-dev @types/react-syntax-highlighter
```

These are standard libraries per RESEARCH.md:
- react-markdown 9.x: Industry standard markdown renderer, safe by default
- react-syntax-highlighter 15.x: Code highlighting with 100+ languages
  </action>
  <verify>
Run `npm ls react-markdown react-syntax-highlighter` - both packages should be listed.
Check package.json contains both dependencies.
  </verify>
  <done>
react-markdown and react-syntax-highlighter installed with TypeScript types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create public action for listing AI messages</name>
  <files>convex/ai/messages.ts</files>
  <action>
Create a new file `convex/ai/messages.ts` with a public **action** that retrieves messages using `investorAssistant.listMessages`.

**Why an action (not a query):**
- The `@convex-dev/agent` stores messages in internal tables
- `investorAssistant.listMessages` requires action context (as seen in chat.ts line 123)
- The internal `listMessagesByThreadId` query cannot be called directly from frontend
- Actions don't support real-time subscriptions, so frontend must poll or refetch after sends

**Implementation:**

```typescript
import { action } from "../_generated/server";
import { api } from "../_generated/api";
import { investorAssistant } from "./agent";

/**
 * List messages for the current user's AI thread.
 * Returns messages in ascending order (oldest first) for display.
 *
 * Note: This is an action (not a query) because investorAssistant.listMessages
 * requires action context. Frontend should refetch after sendMessage completes.
 */
export const listMessages = action({
  args: {},
  handler: async (ctx): Promise<Array<{
    _id: string;
    role: "user" | "assistant";
    content: string;
    _creationTime: number;
  }>> => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      return [];
    }

    // Get user's thread
    const thread = await ctx.runQuery(api.ai.threads.getThreadForUser, {});
    if (!thread || !thread.agentThreadId) {
      return [];
    }

    // List messages using agent API (requires action context)
    const messagesResult = await investorAssistant.listMessages(ctx, {
      threadId: thread.agentThreadId,
      paginationOpts: { numItems: 50, cursor: null },
      excludeToolMessages: true,
      statuses: ["success"],
      order: "asc", // Oldest first for chat display
    });

    // Transform to simplified format for frontend
    return messagesResult.page
      .filter(msg => msg.message && (msg.message.role === "user" || msg.message.role === "assistant"))
      .map(msg => ({
        _id: msg._id,
        role: msg.message!.role as "user" | "assistant",
        content: extractTextFromContent(msg.message!.content),
        _creationTime: msg._creationTime,
      }))
      .filter(msg => msg.content.length > 0);
  },
});

/**
 * Helper: Extract text from message content (handles both string and array content)
 */
function extractTextFromContent(content: unknown): string {
  if (typeof content === "string") {
    return content;
  }
  if (Array.isArray(content)) {
    return content
      .filter((part): part is { type: "text"; text: string } =>
        part && typeof part === "object" && part.type === "text" && typeof part.text === "string"
      )
      .map(part => part.text)
      .join(" ");
  }
  return "";
}
```

Key points:
- Returns empty array if not authenticated or no thread exists
- Uses `order: "asc"` for chronological display
- Filters to only user/assistant messages with content
- Extracts text from complex content structures (same pattern as chat.ts)
  </action>
  <verify>
Run `npx convex dev --once` - no type errors.
The action should export `listMessages` function.
  </verify>
  <done>
Public action available at `api.ai.messages.listMessages` that returns AI conversation messages for the current user.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useAIChat hook and useSmartScroll hook</name>
  <files>src/components/ai/hooks/useAIChat.ts, src/components/ai/hooks/useSmartScroll.ts</files>
  <action>
Create the hooks directory and two hooks for the AI chat.

**useAIChat.ts:**

```typescript
"use client";

import { useQuery, useAction, useMutation } from "convex/react";
import { api } from "@/convex/_generated/api";
import { useState, useCallback, useEffect } from "react";

interface Message {
  _id: string;
  role: "user" | "assistant";
  content: string;
  _creationTime: number;
}

/**
 * Hook for managing AI chat state and actions.
 * Provides: messages, sendMessage, isStreaming, stopGeneration, clearMemory
 *
 * Note: Messages are fetched via action (not query) because the agent component
 * stores messages in internal tables. We refetch after sending messages since
 * actions don't support real-time subscriptions.
 */
export function useAIChat() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [isStreaming, setIsStreaming] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // Get user's thread (for stopGeneration)
  const thread = useQuery(api.ai.threads.getThreadForUser);

  // Actions
  const listMessagesAction = useAction(api.ai.messages.listMessages);
  const sendMessageAction = useAction(api.ai.chat.sendMessage);
  const stopGenerationAction = useAction(api.ai.chat.stopGeneration);
  const clearMemoryMutation = useMutation(api.ai.threads.clearMemory);

  // Fetch messages function
  const fetchMessages = useCallback(async () => {
    try {
      const result = await listMessagesAction();
      setMessages(result);
    } catch (err) {
      console.error("Failed to fetch messages:", err);
    } finally {
      setIsLoading(false);
    }
  }, [listMessagesAction]);

  // Initial load and refetch when thread changes
  useEffect(() => {
    fetchMessages();
  }, [fetchMessages, thread?.agentThreadId]);

  const sendMessage = useCallback(async (text: string) => {
    if (!text.trim()) return;
    setError(null);
    setIsStreaming(true);

    // Optimistically add user message to UI
    const optimisticUserMessage: Message = {
      _id: `temp-${Date.now()}`,
      role: "user",
      content: text,
      _creationTime: Date.now(),
    };
    setMessages(prev => [...prev, optimisticUserMessage]);

    try {
      await sendMessageAction({ message: text });
      // Refetch messages to get the real user message and AI response
      await fetchMessages();
    } catch (err) {
      // Handle abort vs real error
      if (err instanceof Error && err.message.includes("abort")) {
        // User stopped generation - still refetch to get partial response
        await fetchMessages();
      } else {
        setError(err instanceof Error ? err.message : "Failed to send message");
        // Remove optimistic message on error
        setMessages(prev => prev.filter(m => m._id !== optimisticUserMessage._id));
      }
    } finally {
      setIsStreaming(false);
    }
  }, [sendMessageAction, fetchMessages]);

  const stopGeneration = useCallback(async () => {
    if (!thread?._id) return;
    try {
      await stopGenerationAction({ threadId: thread._id });
    } catch (err) {
      console.error("Failed to stop generation:", err);
    }
  }, [thread?._id, stopGenerationAction]);

  const clearMemory = useCallback(async () => {
    try {
      await clearMemoryMutation({});
      setMessages([]); // Clear local state immediately
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to clear memory");
    }
  }, [clearMemoryMutation]);

  return {
    messages,
    isStreaming,
    isLoading,
    error,
    threadId: thread?._id,
    sendMessage,
    stopGeneration,
    clearMemory,
    refetchMessages: fetchMessages,
  };
}
```

**Key implementation details:**
- Uses action-based message fetching with refetch-after-send pattern
- Optimistically adds user message to UI while waiting for response
- Removes optimistic message on error, keeps on success (real message from server)
- Initial load on mount, refetch when thread changes or after sendMessage
- Exposes `refetchMessages` for manual refresh if needed

**useSmartScroll.ts:**

```typescript
"use client";

import { useEffect, useRef, useState, useCallback } from "react";

/**
 * Hook for smart auto-scroll behavior.
 * Only scrolls to bottom if user is near bottom (not interrupting history reading).
 */
export function useSmartScroll<T>(dependency: T) {
  const scrollRef = useRef<HTMLDivElement>(null);
  const bottomRef = useRef<HTMLDivElement>(null);
  const [isNearBottom, setIsNearBottom] = useState(true);

  // Track if user is near bottom using Intersection Observer
  useEffect(() => {
    if (!bottomRef.current) return;

    const observer = new IntersectionObserver(
      ([entry]) => setIsNearBottom(entry.isIntersecting),
      { threshold: 0.1, rootMargin: "50px" }
    );

    observer.observe(bottomRef.current);
    return () => observer.disconnect();
  }, []);

  // Auto-scroll when dependency changes and user is near bottom
  useEffect(() => {
    if (isNearBottom && scrollRef.current) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
    }
  }, [dependency, isNearBottom]);

  const scrollToBottom = useCallback(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
    }
  }, []);

  return { scrollRef, bottomRef, isNearBottom, scrollToBottom };
}
```

Create the directory structure:
```
src/components/ai/
└── hooks/
    ├── useAIChat.ts
    └── useSmartScroll.ts
```
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors in the new hooks.
Verify imports resolve correctly.
  </verify>
  <done>
useAIChat hook provides messages, sendMessage, isStreaming, stopGeneration, clearMemory with action-based refetch pattern.
useSmartScroll hook provides refs and state for smart auto-scroll behavior.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm ls react-markdown react-syntax-highlighter` shows both installed
2. `npx convex dev --once` passes without errors
3. `npx tsc --noEmit` passes without errors
4. Files exist:
   - convex/ai/messages.ts
   - src/components/ai/hooks/useAIChat.ts
   - src/components/ai/hooks/useSmartScroll.ts
</verification>

<success_criteria>
- Markdown dependencies installed and available for import
- Public action exists for listing AI messages (uses investorAssistant.listMessages)
- useAIChat hook encapsulates all chat state with refetch-after-send pattern
- useSmartScroll hook provides Intersection Observer-based scroll detection
- All code passes type checking
</success_criteria>

<output>
After completion, create `.planning/phases/41-conversational-ai-core/41-01-SUMMARY.md`
</output>
