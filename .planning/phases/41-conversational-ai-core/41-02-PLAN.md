---
phase: 41-conversational-ai-core
plan: 02
type: execute
wave: 2
depends_on: ["41-01"]
files_modified:
  - src/components/ai/ChatMessage.tsx
  - src/components/ai/TypingIndicator.tsx
  - src/components/ai/StreamingCursor.tsx
  - src/components/ai/AIChatInput.tsx
autonomous: true

must_haves:
  truths:
    - "AI messages render with markdown formatting including code blocks"
    - "User messages display as right-aligned bubbles"
    - "Typing indicator shows animated dots while AI is thinking"
    - "Streaming cursor blinks at end of in-progress AI response"
    - "Chat input supports Enter to send, Shift+Enter for newline"
  artifacts:
    - path: "src/components/ai/ChatMessage.tsx"
      provides: "Message bubble with markdown rendering"
      exports: ["ChatMessage"]
      min_lines: 50
    - path: "src/components/ai/TypingIndicator.tsx"
      provides: "Animated typing dots"
      exports: ["TypingIndicator"]
    - path: "src/components/ai/StreamingCursor.tsx"
      provides: "Blinking cursor for streaming text"
      exports: ["StreamingCursor"]
    - path: "src/components/ai/AIChatInput.tsx"
      provides: "Chat input with Enter/Shift+Enter handling"
      exports: ["AIChatInput"]
      min_lines: 40
  key_links:
    - from: "src/components/ai/ChatMessage.tsx"
      to: "react-markdown"
      via: "ReactMarkdown component"
      pattern: "import ReactMarkdown"
    - from: "src/components/ai/ChatMessage.tsx"
      to: "react-syntax-highlighter"
      via: "code block rendering"
      pattern: "SyntaxHighlighter"
    - from: "src/components/ai/AIChatInput.tsx"
      to: "parent onSend callback"
      via: "props.onSend"
      pattern: "onSend\\(.*\\)"
---

<objective>
Create the individual UI components for the AI chat interface.

Purpose: Build the visual building blocks - message bubbles with markdown, typing indicator, streaming cursor, and input field. These components will be composed into the main chat panel in Plan 03.

Output: Four React components ready to be assembled into the chat interface.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/41-conversational-ai-core/41-CONTEXT.md
@.planning/phases/41-conversational-ai-core/41-RESEARCH.md
@.planning/phases/41-conversational-ai-core/41-01-SUMMARY.md

# Existing patterns to follow
@src/components/chat/ChatMessage.tsx
@src/components/chat/ChatInput.tsx
@src/components/ui/avatar.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ChatMessage component with markdown rendering</name>
  <files>src/components/ai/ChatMessage.tsx</files>
  <action>
Create the AI chat message component with full markdown support.

**File: src/components/ai/ChatMessage.tsx**

```typescript
"use client";

import { memo } from "react";
import ReactMarkdown from "react-markdown";
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter";
import { oneDark } from "react-syntax-highlighter/dist/cjs/styles/prism";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { cn } from "@/lib/utils";
import { formatDistanceToNow } from "date-fns";
import { StreamingCursor } from "./StreamingCursor";

interface ChatMessageProps {
  role: "user" | "assistant";
  content: string;
  timestamp: number;
  isStreaming?: boolean;
  userImage?: string;
  userName?: string;
}

// Memoize to prevent re-renders during streaming of other messages
export const ChatMessage = memo(function ChatMessage({
  role,
  content,
  timestamp,
  isStreaming = false,
  userImage,
  userName,
}: ChatMessageProps) {
  const isUser = role === "user";

  // Get user initials for fallback
  const getInitials = (name?: string) => {
    if (!name) return "U";
    return name.split(" ").map(n => n[0]).join("").toUpperCase().slice(0, 2);
  };

  return (
    <div
      className={cn(
        "flex gap-3 max-w-[85%]",
        isUser ? "ms-auto flex-row-reverse" : "me-auto"
      )}
    >
      {/* Avatar */}
      <Avatar className="h-8 w-8 flex-shrink-0">
        {isUser ? (
          <>
            <AvatarImage src={userImage} alt={userName || "You"} />
            <AvatarFallback className="text-xs bg-primary text-primary-foreground">
              {getInitials(userName)}
            </AvatarFallback>
          </>
        ) : (
          <>
            <AvatarFallback className="text-xs bg-muted">
              AI
            </AvatarFallback>
          </>
        )}
      </Avatar>

      <div className={cn("flex flex-col", isUser ? "items-end" : "items-start")}>
        {/* Message bubble */}
        <div
          className={cn(
            "px-4 py-2 text-sm",
            isUser
              ? "bg-primary text-primary-foreground rounded-2xl rounded-ee-sm"
              : "bg-muted rounded-2xl rounded-es-sm"
          )}
        >
          {isUser ? (
            // User messages: plain text
            <p className="whitespace-pre-wrap break-words">{content}</p>
          ) : (
            // AI messages: markdown with code highlighting
            <div className="prose prose-sm dark:prose-invert max-w-none">
              <ReactMarkdown
                components={{
                  code({ inline, className, children, ...props }) {
                    const match = /language-(\w+)/.exec(className || "");
                    const codeString = String(children).replace(/\n$/, "");

                    if (!inline && match) {
                      return (
                        <SyntaxHighlighter
                          style={oneDark}
                          language={match[1]}
                          PreTag="div"
                          className="rounded-md !my-2"
                          {...props}
                        >
                          {codeString}
                        </SyntaxHighlighter>
                      );
                    }

                    return (
                      <code
                        className={cn(
                          "bg-muted-foreground/20 px-1 py-0.5 rounded text-sm",
                          className
                        )}
                        {...props}
                      >
                        {children}
                      </code>
                    );
                  },
                  // Ensure links open in new tab
                  a({ children, href, ...props }) {
                    return (
                      <a
                        href={href}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="text-primary underline"
                        {...props}
                      >
                        {children}
                      </a>
                    );
                  },
                }}
              >
                {content}
              </ReactMarkdown>
              {isStreaming && <StreamingCursor />}
            </div>
          )}
        </div>

        {/* Timestamp */}
        <time
          dateTime={new Date(timestamp).toISOString()}
          title={new Date(timestamp).toLocaleString()}
          className="text-xs text-muted-foreground mt-1"
        >
          {formatDistanceToNow(timestamp, { addSuffix: true })}
        </time>
      </div>
    </div>
  );
});
```

Key features:
- User messages: right-aligned, primary color, plain text
- AI messages: left-aligned, muted background, full markdown
- react-markdown with custom code component for syntax highlighting
- Memoized to prevent re-renders during streaming
- Uses existing Avatar component from UI library
- StreamingCursor shown when isStreaming is true
- Timestamp using date-fns formatDistanceToNow
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
Import resolves for react-markdown and react-syntax-highlighter.
  </verify>
  <done>
ChatMessage component renders user and AI messages with markdown support and code highlighting.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TypingIndicator and StreamingCursor components</name>
  <files>src/components/ai/TypingIndicator.tsx, src/components/ai/StreamingCursor.tsx</files>
  <action>
Create two small animation components for streaming feedback.

**File: src/components/ai/TypingIndicator.tsx**

```typescript
"use client";

/**
 * Animated typing indicator (three bouncing dots)
 * Shown before first token arrives from AI
 */
export function TypingIndicator() {
  return (
    <div
      className="flex gap-1 px-4 py-3"
      role="status"
      aria-label="AI is typing"
    >
      <div className="h-2 w-2 rounded-full bg-muted-foreground animate-bounce [animation-delay:-0.3s]" />
      <div className="h-2 w-2 rounded-full bg-muted-foreground animate-bounce [animation-delay:-0.15s]" />
      <div className="h-2 w-2 rounded-full bg-muted-foreground animate-bounce" />
    </div>
  );
}
```

**File: src/components/ai/StreamingCursor.tsx**

```typescript
"use client";

/**
 * Blinking cursor shown at end of streaming AI response
 * Indicates more text is coming
 */
export function StreamingCursor() {
  return (
    <span
      className="inline-block w-0.5 h-4 bg-current animate-pulse ml-0.5 align-middle"
      aria-hidden="true"
    />
  );
}
```

Key features:
- TypingIndicator: Three dots with staggered bounce animation using Tailwind animation-delay
- StreamingCursor: Thin blinking bar using animate-pulse
- Both use aria attributes for accessibility
- Pure CSS animations (no JS timers)
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
Both components export correctly.
  </verify>
  <done>
TypingIndicator shows bouncing dots, StreamingCursor shows blinking bar.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create AIChatInput component</name>
  <files>src/components/ai/AIChatInput.tsx</files>
  <action>
Create the chat input component with Enter/Shift+Enter handling and stop button.

**File: src/components/ai/AIChatInput.tsx**

```typescript
"use client";

import { useState, useRef, useCallback, KeyboardEvent } from "react";
import { Button } from "@/components/ui/button";
import { HugeiconsIcon } from "@hugeicons/react";
import { SentIcon, StopIcon } from "@hugeicons/core-free-icons";
import { cn } from "@/lib/utils";

interface AIChatInputProps {
  onSend: (message: string) => void;
  onStop?: () => void;
  disabled?: boolean;
  isStreaming?: boolean;
  placeholder?: string;
}

export function AIChatInput({
  onSend,
  onStop,
  disabled = false,
  isStreaming = false,
  placeholder = "Type a message... (Enter to send, Shift+Enter for new line)",
}: AIChatInputProps) {
  const [value, setValue] = useState("");
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  // Auto-resize textarea (up to ~4 lines)
  const adjustHeight = useCallback(() => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = "auto";
      const maxHeight = 120; // ~4 lines
      textarea.style.height = `${Math.min(textarea.scrollHeight, maxHeight)}px`;
    }
  }, []);

  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setValue(e.target.value);
    adjustHeight();
  };

  const handleSend = useCallback(() => {
    const trimmed = value.trim();
    if (trimmed && !disabled && !isStreaming) {
      onSend(trimmed);
      setValue("");
      // Reset height after clearing
      if (textareaRef.current) {
        textareaRef.current.style.height = "auto";
      }
    }
  }, [value, disabled, isStreaming, onSend]);

  const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>) => {
    // Enter sends (if not disabled/streaming), Shift+Enter adds newline
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  const isEmpty = value.trim().length === 0;
  const inputDisabled = disabled || isStreaming;

  return (
    <div className="flex items-end gap-2 px-3 py-2 border-t bg-background flex-shrink-0">
      <textarea
        ref={textareaRef}
        value={value}
        onChange={handleChange}
        onKeyDown={handleKeyDown}
        placeholder={placeholder}
        disabled={inputDisabled}
        rows={1}
        className={cn(
          "flex-1 resize-none rounded-lg border bg-transparent px-3 py-2 text-sm",
          "placeholder:text-muted-foreground",
          "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring",
          "disabled:cursor-not-allowed disabled:opacity-50",
          "min-h-[40px]"
        )}
        aria-label="Message input"
      />

      {isStreaming ? (
        // Stop button during streaming
        <Button
          onClick={onStop}
          variant="destructive"
          size="icon"
          className="h-10 w-10 flex-shrink-0"
          aria-label="Stop generating"
        >
          <HugeiconsIcon icon={StopIcon} size={18} />
        </Button>
      ) : (
        // Send button
        <Button
          onClick={handleSend}
          disabled={inputDisabled || isEmpty}
          size="icon"
          className="h-10 w-10 flex-shrink-0"
          aria-label="Send message"
        >
          <HugeiconsIcon icon={SentIcon} size={18} />
        </Button>
      )}
    </div>
  );
}
```

Key features:
- Enter sends message, Shift+Enter creates newline (per CONTEXT.md decision)
- Auto-growing textarea up to ~4 lines
- Input disabled while streaming (per CONTEXT.md decision)
- Stop button appears during streaming (swaps with Send button)
- Uses same styling pattern as existing ChatInput.tsx
- Accessible with aria-labels
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
Verify HugeiconsIcon and icons import correctly (check if StopIcon exists, may need to adjust icon name).
  </verify>
  <done>
AIChatInput component with Enter/Shift+Enter handling, auto-grow textarea, and streaming stop button.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes without errors
2. Files exist with correct exports:
   - src/components/ai/ChatMessage.tsx exports ChatMessage
   - src/components/ai/TypingIndicator.tsx exports TypingIndicator
   - src/components/ai/StreamingCursor.tsx exports StreamingCursor
   - src/components/ai/AIChatInput.tsx exports AIChatInput
3. Components use consistent styling with existing chat components
</verification>

<success_criteria>
- ChatMessage renders both user (plain text) and AI (markdown) messages correctly
- Code blocks in AI messages have syntax highlighting
- TypingIndicator shows animated bouncing dots
- StreamingCursor shows blinking bar at end of text
- AIChatInput handles Enter to send, Shift+Enter for newline
- Stop button appears during streaming
- All components are accessible (aria attributes)
</success_criteria>

<output>
After completion, create `.planning/phases/41-conversational-ai-core/41-02-SUMMARY.md`
</output>
