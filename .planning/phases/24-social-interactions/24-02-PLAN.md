---
phase: 24-social-interactions
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/posts.ts
autonomous: true

must_haves:
  truths:
    - "Comments table stores comment text with author and post references"
    - "User can add a comment to any post they can view"
    - "Comments can be fetched for a given post (paginated)"
    - "commentCount on post increments when comment added"
  artifacts:
    - path: "convex/schema.ts"
      provides: "postComments table definition"
      contains: "postComments: defineTable"
    - path: "convex/posts.ts"
      provides: "addComment mutation and getComments query"
      exports: ["addComment", "getComments"]
  key_links:
    - from: "convex/posts.ts addComment"
      to: "postComments table"
      via: "ctx.db.insert"
      pattern: "ctx.db.insert.*postComments"
---

<objective>
Add comments schema and backend mutations for post comments

Purpose: Enable users to comment on posts with proper data storage and retrieval
Output: postComments table in schema, addComment mutation, getComments query
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@convex/schema.ts (posts table with commentCount field)
@convex/posts.ts (existing like/save mutations pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add postComments table to schema</name>
  <files>convex/schema.ts</files>
  <action>
Add a new postComments table after the postSaves table definition:

```typescript
// Post comments
postComments: defineTable({
  postId: v.id("posts"),
  authorId: v.id("users"),
  content: v.string(),
  createdAt: v.number(),
})
  .index("by_post", ["postId"])
  .index("by_post_and_time", ["postId", "createdAt"])
  .index("by_author", ["authorId"]),
```

Fields:
- `postId`: Reference to the post being commented on
- `authorId`: User who wrote the comment
- `content`: Comment text (required, non-empty)
- `createdAt`: Timestamp for ordering

Indexes:
- `by_post`: Fetch all comments on a post
- `by_post_and_time`: Paginated fetch with time ordering
- `by_author`: Find all comments by a user (for profile pages later)
  </action>
  <verify>`npx convex dev` runs without schema errors</verify>
  <done>postComments table added to schema with proper indexes</done>
</task>

<task type="auto">
  <name>Task 2: Add comment mutations and queries to posts.ts</name>
  <files>convex/posts.ts</files>
  <action>
Add at the bottom of posts.ts (before the closing of the file):

1. **addComment mutation:**
```typescript
// Add a comment to a post
export const addComment = mutation({
  args: {
    postId: v.id("posts"),
    content: v.string(),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerk_id", (q) => q.eq("clerkId", identity.subject))
      .unique();

    if (!user) {
      throw new Error("User not found");
    }

    // Validate post exists
    const post = await ctx.db.get(args.postId);
    if (!post) {
      throw new Error("Post not found");
    }

    // Validate content is not empty
    const trimmedContent = args.content.trim();
    if (!trimmedContent) {
      throw new Error("Comment cannot be empty");
    }

    // Limit comment length (1000 chars)
    if (trimmedContent.length > 1000) {
      throw new Error("Comment too long (max 1000 characters)");
    }

    // Insert comment
    const commentId = await ctx.db.insert("postComments", {
      postId: args.postId,
      authorId: user._id,
      content: trimmedContent,
      createdAt: Date.now(),
    });

    // Increment commentCount on post
    await ctx.db.patch(args.postId, {
      commentCount: post.commentCount + 1,
    });

    return commentId;
  },
});
```

2. **getComments query (paginated):**
```typescript
// Get comments for a post (paginated, newest first)
export const getComments = query({
  args: {
    postId: v.id("posts"),
    paginationOpts: paginationOptsValidator,
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      return { page: [], isDone: true, continueCursor: "" };
    }

    // Get comments with pagination, newest first
    const results = await ctx.db
      .query("postComments")
      .withIndex("by_post_and_time", (q) => q.eq("postId", args.postId))
      .order("desc")
      .paginate(args.paginationOpts);

    // Enrich with author info
    const enrichedPage = await Promise.all(
      results.page.map(async (comment) => {
        const author = await ctx.db.get(comment.authorId);
        return {
          ...comment,
          authorName: author?.name || author?.email || "Unknown",
          authorImageUrl: author?.imageUrl,
          authorRole: author?.role,
        };
      })
    );

    return {
      ...results,
      page: enrichedPage,
    };
  },
});
```

Both follow established patterns from likePost/unlikePost (auth check, user lookup, validation, atomic counter update).
  </action>
  <verify>`npx convex dev` syncs without errors, mutations appear in generated API</verify>
  <done>addComment mutation and getComments query added with auth, validation, and atomic counter update</done>
</task>

</tasks>

<verification>
1. Run `npx convex dev` - should sync schema and functions
2. Check Convex dashboard - postComments table exists
3. Test via Convex dashboard or API:
   - Call addComment with valid postId and content
   - Verify comment appears in postComments table
   - Verify commentCount incremented on the post
   - Call getComments - should return the comment with author info
</verification>

<success_criteria>
- postComments table created with postId, authorId, content, createdAt
- addComment validates auth, non-empty content, max 1000 chars
- addComment atomically increments commentCount on post
- getComments returns paginated comments with author name/image/role
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/24-social-interactions/24-02-SUMMARY.md`
</output>
