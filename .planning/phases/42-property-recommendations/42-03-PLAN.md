---
phase: 42-property-recommendations
plan: 03
type: execute
wave: 2
depends_on: [42-01, 42-02]
files_modified:
  - src/components/ai/ChatMessage.tsx
  - src/components/ai/hooks/useAIChat.ts
  - src/components/ai/index.ts
  - convex/ai/messages.ts
  - src/components/ai/ChatMessageList.tsx
  - src/components/ai/PropertyCardRenderer.tsx
autonomous: false

must_haves:
  truths:
    - "Property cards appear inline in AI messages after tool execution"
    - "Save All button appears after property cards when 2+ properties shown"
    - "User can ask follow-up questions about recommended properties"
    - "AI never mentions properties that don't exist in database"
    - "Loading indicator shows while AI searches properties (REC-06)"
  artifacts:
    - path: "src/components/ai/ChatMessage.tsx"
      provides: "Message rendering with tool status indicator"
      contains: "isToolExecuting"
    - path: "src/components/ai/PropertyCardRenderer.tsx"
      provides: "Extracts and renders property cards from tool results"
      exports: ["PropertyCardRenderer"]
    - path: "src/components/ai/hooks/useAIChat.ts"
      provides: "Hook returning tool results and tool execution state"
      contains: "toolResults"
    - path: "convex/ai/messages.ts"
      provides: "Messages action returning tool-call content from assistant messages"
      contains: "toolCalls"
    - path: "src/components/ai/index.ts"
      provides: "Updated exports including property components"
      exports: ["PropertyRecommendationCard", "PropertyDetailModal", "SaveAllButton", "PropertyCardRenderer"]
  key_links:
    - from: "src/components/ai/ChatMessage.tsx"
      to: "src/components/ai/PropertyCardRenderer.tsx"
      via: "Renders PropertyCardRenderer with toolCalls"
      pattern: "PropertyCardRenderer"
    - from: "src/components/ai/PropertyCardRenderer.tsx"
      to: "src/components/ai/PropertyRecommendationCard.tsx"
      via: "Renders cards from extracted properties"
      pattern: "PropertyRecommendationCard"
    - from: "src/components/ai/PropertyCardRenderer.tsx"
      to: "src/components/ai/SaveAllButton.tsx"
      via: "Renders after property cards"
      pattern: "SaveAllButton"
    - from: "convex/ai/messages.ts"
      to: "@convex-dev/agent message format"
      via: "Extracts tool-call parts from assistant message content array"
      pattern: "type.*tool-call"
---

<objective>
Wire property recommendation UI into the existing chat interface so property cards appear inline in AI messages, with loading indicator during tool execution.

Purpose: Complete the property recommendations feature by integrating tool results rendering into the chat flow.
Output: ChatMessage extended with loading state and property cards, useAIChat extended with tool data, PropertyCardRenderer component
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-property-recommendations/42-CONTEXT.md
@.planning/phases/42-property-recommendations/42-RESEARCH.md
@.planning/phases/42-property-recommendations/42-01-SUMMARY.md
@.planning/phases/42-property-recommendations/42-02-SUMMARY.md
@src/components/ai/ChatMessage.tsx
@src/components/ai/hooks/useAIChat.ts
@convex/ai/messages.ts
@node_modules/@convex-dev/agent/dist/client/messages.d.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update messages.ts to return tool call data from assistant message content</name>
  <files>convex/ai/messages.ts</files>
  <action>
The current `listMessages` action uses `excludeToolMessages: true` which filters out standalone tool messages (role: "tool"). However, tool call information is ALSO embedded in assistant messages when their content is an array containing `type: "tool-call"` parts.

Based on the @convex-dev/agent message format (from messages.d.ts lines 176-224), assistant messages with tools have content arrays containing:
- `{ type: "text", text: string }` - the text response
- `{ type: "tool-call", toolCallId: string, toolName: string, args: any }` - tool invocations

Update `convex/ai/messages.ts`:

1. Keep `excludeToolMessages: true` (we don't need separate "tool" role messages)

2. Update the return type to include tool calls:
```typescript
handler: async (ctx): Promise<Array<{
  _id: string;
  role: "user" | "assistant";
  content: string;
  _creationTime: number;
  toolCalls?: Array<{
    toolName: string;
    args: Record<string, unknown>;
    result?: unknown;
  }>;
}>> => {
```

3. Extract tool-call parts from assistant message content:
```typescript
// Transform to simplified format for frontend
return messagesResult.page
  .filter(msg => msg.message && (msg.message.role === "user" || msg.message.role === "assistant"))
  .map(msg => {
    const message = msg.message!;

    // Extract tool calls from assistant message content array
    let toolCalls: Array<{ toolName: string; args: Record<string, unknown>; result?: unknown }> | undefined;

    if (message.role === "assistant" && Array.isArray(message.content)) {
      const toolCallParts = message.content.filter(
        (part): part is { type: "tool-call"; toolName: string; args: any; toolCallId: string } =>
          part && typeof part === "object" && part.type === "tool-call"
      );

      if (toolCallParts.length > 0) {
        // Find corresponding tool results in the same content array
        const toolResultParts = message.content.filter(
          (part): part is { type: "tool-result"; toolName: string; result: any; toolCallId: string } =>
            part && typeof part === "object" && part.type === "tool-result"
        );

        toolCalls = toolCallParts.map(tc => {
          const result = toolResultParts.find(tr => tr.toolCallId === tc.toolCallId);
          return {
            toolName: tc.toolName,
            args: tc.args || {},
            result: result?.result,
          };
        });
      }
    }

    return {
      _id: msg._id,
      role: message.role as "user" | "assistant",
      content: extractTextFromContent(message.content),
      _creationTime: msg._creationTime,
      ...(toolCalls && toolCalls.length > 0 ? { toolCalls } : {}),
    };
  })
  .filter(msg => msg.content.length > 0 || (msg.toolCalls && msg.toolCalls.length > 0));
```

Key insight: The tool results are stored in the same assistant message content array as "tool-result" parts, paired with "tool-call" parts via toolCallId. We don't need the separate "tool" role messages.

Note: The filter at the end now keeps messages that have content OR toolCalls (to show tool execution even if text is pending).
  </action>
  <verify>
Run `npx convex dev` - no TypeScript errors.
Add a test message asking for property recommendations and check console.log output for toolCalls array.
  </verify>
  <done>
listMessages returns toolCalls array extracted from assistant message content, paired with results via toolCallId.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PropertyCardRenderer component for tool result extraction and rendering</name>
  <files>src/components/ai/PropertyCardRenderer.tsx</files>
  <action>
Create a new component that handles the complexity of extracting property data from tool results and rendering cards. This keeps ChatMessage cleaner (addressing scope_sanity warning).

Create `src/components/ai/PropertyCardRenderer.tsx`:

```typescript
"use client";

import { PropertyRecommendationCard } from "./PropertyRecommendationCard";
import { SaveAllButton } from "./SaveAllButton";

interface ToolCall {
  toolName: string;
  args: Record<string, unknown>;
  result?: unknown;
}

interface PropertyCardRendererProps {
  toolCalls?: ToolCall[];
  isExecuting?: boolean;
}

// Type guard for searchProperties result
interface SearchPropertiesResult {
  properties: Array<{
    _id: string;
    title: string;
    city: string;
    address: string;
    priceUsd: number;
    bedrooms?: number;
    bathrooms?: number;
    squareMeters?: number;
    propertyType: string;
    featuredImage?: string;
    expectedRoi?: number;
    capRate?: number;
  }>;
  searchCriteria: {
    budgetMin?: number;
    budgetMax?: number;
    cities?: string[];
    propertyTypes?: string[];
    minBedrooms?: number;
  };
  count: number;
  message: string;
}

function isSearchPropertiesResult(result: unknown): result is SearchPropertiesResult {
  return (
    result !== null &&
    typeof result === "object" &&
    "properties" in result &&
    Array.isArray((result as SearchPropertiesResult).properties)
  );
}

export function PropertyCardRenderer({ toolCalls, isExecuting }: PropertyCardRendererProps) {
  // Find searchProperties tool call
  const searchToolCall = toolCalls?.find(tc => tc.toolName === "searchProperties");

  // Show loading state if tool is executing but no result yet
  if (isExecuting && searchToolCall && !searchToolCall.result) {
    return (
      <div className="mt-4 flex items-center gap-2 text-sm text-muted-foreground">
        <div className="h-4 w-4 animate-spin rounded-full border-2 border-primary border-t-transparent" />
        <span>Searching properties...</span>
      </div>
    );
  }

  // No tool calls or no searchProperties
  if (!searchToolCall?.result) {
    return null;
  }

  // Validate result structure
  if (!isSearchPropertiesResult(searchToolCall.result)) {
    console.warn("Invalid searchProperties result structure:", searchToolCall.result);
    return null;
  }

  const { properties, searchCriteria } = searchToolCall.result;

  if (properties.length === 0) {
    return null; // AI text will explain no results found
  }

  return (
    <div className="mt-4 space-y-3">
      {properties.map((property) => (
        <PropertyRecommendationCard
          key={property._id}
          property={property}
          searchCriteria={searchCriteria}
        />
      ))}
      {properties.length > 1 && (
        <SaveAllButton propertyIds={properties.map((p) => p._id)} />
      )}
    </div>
  );
}
```

Key features:
- Extracts searchProperties tool call from toolCalls array
- Shows animated loading indicator during tool execution (REC-06)
- Type-guards the result structure for safety
- Renders PropertyRecommendationCard for each property
- Shows SaveAllButton for 2+ properties
  </action>
  <verify>
Run `npx tsc --noEmit` - no TypeScript errors.
Check component exports PropertyCardRenderer.
  </verify>
  <done>
PropertyCardRenderer extracts tool results, shows loading indicator during search, renders property cards with SaveAllButton.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update useAIChat hook and ChatMessage to support tool data and loading state</name>
  <files>src/components/ai/hooks/useAIChat.ts, src/components/ai/ChatMessage.tsx, src/components/ai/ChatMessageList.tsx</files>
  <action>
**1. Update `src/components/ai/hooks/useAIChat.ts`:**

Extend the Message interface and hook to include tool data:

```typescript
interface ToolCall {
  toolName: string;
  args: Record<string, unknown>;
  result?: unknown;
}

interface Message {
  _id: string;
  role: "user" | "assistant";
  content: string;
  _creationTime: number;
  toolCalls?: ToolCall[];
}
```

The hook already returns messages from the backend - no other changes needed if backend returns toolCalls.

**2. Update `src/components/ai/ChatMessage.tsx`:**

Add import and extend props:
```typescript
import { PropertyCardRenderer } from "./PropertyCardRenderer";

interface ToolCall {
  toolName: string;
  args: Record<string, unknown>;
  result?: unknown;
}

interface ChatMessageProps {
  role: "user" | "assistant";
  content: string;
  timestamp: number;
  isStreaming?: boolean;
  userImage?: string;
  userName?: string;
  toolCalls?: ToolCall[];
}
```

After the ReactMarkdown block (inside the AI message bubble, after `{isStreaming && <StreamingCursor />}`), add:

```tsx
{/* Property cards from tool results */}
{role === "assistant" && (
  <PropertyCardRenderer
    toolCalls={toolCalls}
    isExecuting={isStreaming}
  />
)}
```

Key points:
- Only render for assistant messages
- Pass isStreaming as isExecuting to show loading indicator
- PropertyCardRenderer handles all the extraction logic

**3. Update `src/components/ai/ChatMessageList.tsx`:**

Pass toolCalls through to ChatMessage:

```tsx
<ChatMessage
  key={message._id}
  role={message.role}
  content={message.content}
  timestamp={message._creationTime}
  isStreaming={isStreaming && index === messages.length - 1 && message.role === "assistant"}
  userImage={userImage}
  userName={userName}
  toolCalls={message.toolCalls}
/>
```

Note: Read the existing ChatMessageList first to adapt prop passing to current structure.
  </action>
  <verify>
Run `npx tsc --noEmit` - no TypeScript errors.
Check useAIChat returns messages with toolCalls type.
Check ChatMessage renders PropertyCardRenderer.
Check ChatMessageList passes toolCalls prop.
  </verify>
  <done>
useAIChat types include toolCalls, ChatMessage renders PropertyCardRenderer with loading state support, ChatMessageList passes toolCalls through.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update barrel exports</name>
  <files>src/components/ai/index.ts</files>
  <action>
Update `src/components/ai/index.ts` to export all new components:

```typescript
// Property Recommendation Components
export { PropertyRecommendationCard } from "./PropertyRecommendationCard";
export { PropertyDetailModal } from "./PropertyDetailModal";
export { SaveAllButton } from "./SaveAllButton";
export { PropertyCardRenderer } from "./PropertyCardRenderer";

// Hooks
export { usePropertySave } from "./hooks/usePropertySave";
```

Keep all existing exports intact.
  </action>
  <verify>
Run `npx tsc --noEmit` - no TypeScript errors.
Verify all exports in index.ts.
  </verify>
  <done>
Barrel exports include PropertyCardRenderer and all property recommendation components.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete property recommendations feature:
- AI can search properties based on investor criteria
- Loading indicator ("Searching properties...") shows during tool execution
- Property cards appear inline in chat messages
- Each card shows photo, price, location, beds, sqm with match badges
- AI explains 2-3 reasons why each property matches
- Clicking a card opens detail modal
- Save All button saves all recommended properties
- Toast notifications confirm saves
  </what-built>
  <how-to-verify>
1. Start the dev server: `npm run dev`
2. Log in as an investor user
3. Open the AI chat panel
4. Send a message: "Show me properties in Tel Aviv under $500,000"
5. Verify loading state:
   - "Searching properties..." with spinner appears while tool executes
   - This indicates REC-06 is working
6. Verify property cards appear:
   - Cards show: thumbnail, title, price, beds/baths/sqm
   - Match badges reflect search criteria (e.g., "Tel Aviv", "Under $500K")
7. Verify AI explanation:
   - AI text includes 2-3 specific reasons for each property
   - Reasons reference actual property data (price, location, bedrooms)
8. Click a property card:
   - Modal opens with full property details
   - Image, price, metrics, description visible
   - Save button and "View Full Details" link work
9. Close modal, click "Save All X Properties" button:
   - Toast shows "X properties saved"
   - Button changes to "Saved"
10. Send follow-up: "Tell me more about the first one"
    - AI should reference the property from context
11. Try: "What properties do you have in Jerusalem?"
    - Different results based on new criteria
12. Verify no hallucinations:
    - All mentioned properties have corresponding cards
    - AI doesn't invent properties not shown in cards

If any issues found, describe what's broken.
  </how-to-verify>
  <resume-signal>Type "approved" to complete the phase, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run dev` runs without errors
2. Loading indicator appears during property search (REC-06)
3. Property cards appear in AI messages after tool execution
4. AI explains match reasons in text (REC-02)
5. Cards are interactive (click -> modal, save -> toast)
6. Save All button appears for 2+ properties
7. Follow-up questions work with property context
8. All components exported from barrel file
</verification>

<success_criteria>
- AI recommends 3 properties based on investor criteria (REC-01)
- Each recommendation shows 2-3 match reasons in AI text (REC-02)
- Match badges appear on cards (REC-03)
- "Quick save all" saves all properties with toast (REC-04)
- Property cards link to detail modal (REC-05)
- Loading indicator shows during property search (REC-06)
- All properties exist in database - no hallucinations (REC-07)
- AI answers questions about properties (CHAT-07)
</success_criteria>

<output>
After completion, create `.planning/phases/42-property-recommendations/42-03-SUMMARY.md`
</output>
