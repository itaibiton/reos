---
phase: 08-real-time-features
plan: 01
type: execute
---

<objective>
Add notifications schema and backend queries/mutations for real-time event alerts.

Purpose: Enable users to be notified of important events (new messages, deal updates, file uploads, request responses) without needing to actively monitor each page.
Output: Notifications table in schema, queries for fetching notifications, mutations for creating and marking as read.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior work:
@.planning/phases/06.1-multi-layout-chat/06.1-03-SUMMARY.md

# Key files:
@convex/schema.ts
@convex/messages.ts
@convex/deals.ts
@convex/serviceRequests.ts
@convex/dealFiles.ts

**Tech stack available:** Convex, Next.js, Clerk auth
**Established patterns:**
- Convex queries with auth checks
- by_user indexes for user-scoped data
- Enrichment pattern (fetch related data in queries)

**Constraining decisions:**
- Phase 6.1: Messages already have real-time via Convex subscriptions
- Phase 6: dealActivity table tracks deal events (can trigger notifications)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add notifications table to schema</name>
  <files>convex/schema.ts</files>
  <action>
Add a notifications table with fields:
- userId: v.id("users") - recipient of notification
- type: union of notification types (new_message, deal_stage_change, file_uploaded, request_received, request_accepted, request_declined)
- title: v.string() - short notification title
- message: v.string() - notification body text
- read: v.boolean() - whether user has seen it
- link: v.optional(v.string()) - URL to navigate to when clicked
- metadata: v.object with optional fields for dealId, propertyId, senderId, etc.
- createdAt: v.number()

Add indexes:
- by_user: ["userId"]
- by_user_and_read: ["userId", "read"] for fetching unread
- by_user_and_time: ["userId", "createdAt"] for sorted list

Define notificationType union at top of file with other type definitions.
  </action>
  <verify>npx convex dev --once succeeds, types regenerate</verify>
  <done>Notifications table defined with proper indexes, Convex types updated</done>
</task>

<task type="auto">
  <name>Task 2: Create notifications backend (queries + mutations)</name>
  <files>convex/notifications.ts</files>
  <action>
Create convex/notifications.ts with:

**Queries:**
1. list - Get user's notifications (most recent first, limit 20)
   - Auth check, get user by clerkId
   - Query by_user_and_time index descending
   - Enrich with sender info if senderId in metadata

2. getUnreadCount - Get count of unread notifications
   - Auth check, get user
   - Query by_user_and_read where read=false
   - Return count

**Mutations:**
1. markAsRead - Mark a single notification as read
   - Args: notificationId
   - Auth check, verify user owns notification
   - Patch read=true

2. markAllAsRead - Mark all user's notifications as read
   - Auth check, get user
   - Query all unread for user
   - Patch all to read=true

3. create - Internal mutation to create notification (called by other mutations)
   - Args: userId, type, title, message, link?, metadata?
   - Insert notification with read=false, createdAt=Date.now()

**Internal helper function:**
createNotification(ctx, data) - reusable function for other files to import
  </action>
  <verify>npx convex dev --once succeeds, all functions exported</verify>
  <done>Notifications module with list, getUnreadCount, markAsRead, markAllAsRead, create</done>
</task>

<task type="auto">
  <name>Task 3: Integrate notification creation into existing mutations</name>
  <files>convex/messages.ts, convex/serviceRequests.ts, convex/deals.ts, convex/dealFiles.ts</files>
  <action>
Add notification triggers to existing mutations:

**convex/messages.ts - send mutation:**
After creating message, create notification for recipient:
- type: "new_message"
- title: "{senderName} sent you a message"
- message: First 100 chars of content + "..."
- link: "/chat" (chat page with deal context)
- metadata: { dealId, senderId }

**convex/serviceRequests.ts - create mutation (if exists) or accept/decline:**
- On request created: notify provider (type: request_received)
- On accepted: notify investor (type: request_accepted)
- On declined: notify investor (type: request_declined)

**convex/deals.ts - updateStage mutation (if exists):**
- On stage change: notify all participants (type: deal_stage_change)

**convex/dealFiles.ts - saveFile mutation (if exists):**
- On file upload: notify other deal participants (type: file_uploaded)

Import the create mutation from notifications.ts and call it after primary action.
Keep notification creation non-blocking (don't await, let it happen async).
  </action>
  <verify>npx convex dev --once succeeds, send a test message creates notification in DB</verify>
  <done>Notifications automatically created for messages, requests, stage changes, file uploads</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx convex dev --once` succeeds with no errors
- [ ] notifications table appears in Convex dashboard
- [ ] Sending a message creates a notification for recipient
- [ ] No TypeScript errors
</verification>

<success_criteria>
- Notifications schema with proper types and indexes
- CRUD operations for notifications working
- Existing mutations trigger notification creation
- No build errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-real-time-features/08-01-SUMMARY.md`
</output>
